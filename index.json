[{"authors":null,"categories":null,"content":"Hey, I\u0026rsquo;m Neel!\nI\u0026rsquo;m a new grad software engineer at Databricks in San Francisco, CA.\nPreviously, at UMich, I enjoyed some advanced coursework focused on distributed systems, compilers, and machine learning, held a short research stint in deep learning based image reconstruction, was the head of projects for a technical consulting organization, led a video game reinforcement learning project for Michigan Data Science Team, and spent my summers interning at large and small tech companies.\nPersonally, I can solve a Rubik\u0026rsquo;s cube in about 10 seconds, enjoy an occasional New York Times Crossword puzzle, and like to stay active.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"c5bc44517c8bf39e10459d11db47c43b","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Hey, I\u0026rsquo;m Neel!\nI\u0026rsquo;m a new grad software engineer at Databricks in San Francisco, CA.\nPreviously, at UMich, I enjoyed some advanced coursework focused on distributed systems, compilers, and machine learning, held a short research stint in deep learning based image reconstruction, was the head of projects for a technical consulting organization, led a video game reinforcement learning project for Michigan Data Science Team, and spent my summers interning at large and small tech companies.","tags":null,"title":"Neel Shah","type":"authors"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature.   Slides can be added in a few ways:\n Create slides using Wowchemy\u0026rsquo;s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further event details, including page elements such as image galleries, can be added to the body of this page.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1906549200,"objectID":"a8edef490afe42206247b6ac05657af0","permalink":"https://www.neelsh.com/talk/example-talk/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example-talk/","section":"event","summary":"An example talk using Wowchemy's Markdown slides feature.","tags":[],"title":"Example Talk","type":"event"},{"authors":[],"categories":[],"content":"I deeply enjoyed Advanced Compilers - my final technical course in university and my first dabble into formally studying compilers. For the final project, I teamed up with classmates to build a compilers or compilers-adjacent research project.\nInfluenced by some ideas present in this paper presenting an approximate computing framework, we sought to implement build ideas in approximate computing, a study that trades program accuracy for improvements in speed and/or memory usage. The quintessential example of approximate computing is loop perforation, which modifies the source to skip loop iterations. After surveying other relevant papers, we converged on a few actionable ideas:\n Expand ACCEPT to contain more approximate computing techniques. Ironically, I could not compile the ACCEPT compiler framework after days of hacking away and squashing compiler bugs as they appeared (dependencies suck). That idea was out of question Implement alternate algorithm selection (such as using a less accurate but fast matrix multiplication algorithm in certain scenarios for image processing or machine learning training/inference) or alternate data structure selection (can we determine at compile time which implementation of a key-value store is best for the workload?)  While whiteboarding through some ideas and potential timelines, two techniques lingered in my mind: small-angle approximation (the property that $\\sin(x) \\approxeq x$ when $x$ is small) and Taylor approximations (you can estimate continuous functions with some derivatives). We realized that, in general, if we assume that functions are continuous, we can approximate values quite easily. The accuracy of the approximations depends on the function\u0026rsquo;s gradient and the point around which we find the approximation. A flat horizontal line is the perfect case. We decided to maximize speed by assigning a fixed value to each input interval - equivalent to a 0th order Taylor approximation.\nThus Nearby-operand Continuous Approximation (NOCAP) was borne. The user annotates candidate double -\u0026gt; double functions to annotate. The NOCAP profiler identifies a range of inputs based on sample input. Then, with user-specified memory usage, NOCAP replaces function calls to candidate functions with table queries, falling back to the original if the input is out of range. NOCAP trades accuracy and memory usage for speed.\nWe used two benchmarks - a toy example using the built-in exp() function in math.h - and an implementation of Black-Scholes that uses exp(), log(), sqrt() in math.h. In the toy example, NOCAP shows a 60% speedup for 200 million calls to exp() but less than a 1% speedup for Black-Scholes. These speedups are statistically verified. NOCAP demonstrates speedup but in code where math functions are such a small part of CPU usage, the speedup is negligible. Exp is also a bad example to use NOCAP outside of demonstrating speedup because of accuracy losses resulting from the very large and very small gradients at both ends of the input spectrum.\nHowever, table lookup could suffer a bottleneck to cache size/RAM size.\nGet ready for some napkin math\u0026hellip;\nNapkin math Based on ChatGPT and a Google/Quora/Stack Overflow for \u0026ldquo;modern processors\u0026rdquo; (I can\u0026rsquo;t be bothered to keep track of sources for napkin math), addition/subtraction/multiplication/L1 cache hit (~1-2 cycles) \u0026lt;= division/L3 cache hit (~30 cycles) \u0026lt;= local SRAM/DRAM (~100 cycles or more) (SRAM is faster). Are these numbers totally accurate? Definitely not, but I think we can see a general pattern arise. It takes a lot of arithmetic to be slower than RAM access but not that much to be slower than an L3 cache hit.\nSuppose we have some modern hardware with a relatively large L3 cache - 32MB. NOCAP can accommodate a max of 4 million table entries. With a .01 interval size, we can only accommodate a max range of 40,000. Instead, if we spend $15,000, we can get a 1.1GB L3 cache, giving us a max range of ~1.3 million - a bit better!\nMaybe the function is really slow, and using RAM is worth it. 64GB of RAM affords you ~83 million range and 1TB of RAM affords you ~1.3 billion range - a lot better!\nNote that the ranges aren\u0026rsquo;t quite correct because doubles are stored using the IEEE floating point technique.\nConclusion NOCAP was a fun project to work on and maybe the ideas presented are useful for a specific use case. However, I don\u0026rsquo;t think NOCAP is useful for 99.999999% of continuous functions, especially if only arithmetic is used to compute it (e.g. no blocking operations or syscalls). Perhaps it\u0026rsquo;s better than a lot of division but I have not verified that claim. Practically, L3 cache hits are the most frequent NOCAP queries, and the L3 cache is almost always too small for any reasonable range of inputs.\nEnjoy demo slides and our paper on the project.\nDemo Slides\n Paper\n ","date":1689124317,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1689124317,"objectID":"0ad7dd68c6eeafca37082c23590d6928","permalink":"https://www.neelsh.com/post/nocap/","publishdate":"2023-07-11T21:11:57-04:00","relpermalink":"/post/nocap/","section":"post","summary":"A walk through my final project of university","tags":[],"title":"NOCAP: A not-so-useful precompilation framework","type":"post"},{"authors":["Neel Shah"],"categories":[],"content":"Intro During the Winter 2021 semester, I decided to lead a project team within Michigan Data Science Team. Overall, I think the project was successful; each team generated interesting results. Many enjoyed the project, tackled each work session with dedication, and finished the project with newfound knowledge. Leading PokeRL will resonate with me for years to come.\nUsually, MDST projects follow a traditional \u0026lsquo;data science\u0026rsquo; workflow: develop an objective, create/find a meaningful dataset, understand the data, build a model, analyze the model\u0026rsquo;s performance on objective, and iterate.\nI opted to try a non-traditional, exploratory topic: Reinforcement Learning. Specifically, I tasked my team to try to create AI for a game called Pokemon Showdown, which I will call Showdown for the rest of this post.\nMotivation Quite a few reasons compelled me to choose Showdown over other games. First, Showdown is a fairly popular online game with around 15,000 users online at a given time. We can also test AI agents against real people using the ELO system. Second, Showdown is an open, unstudied game unlike chess, tetris, or poker. I didn\u0026rsquo;t want students copying from other literature to encourage fresh ideas unique to Showdown. Third, Showdown is open source and a Python library exists to interact with the website (both prod and local versions) to create AI agents. Lastly, Showdown is a zero-sum two-player imperfect information game. What does this mean? Showdown games have two players with one winner and no draws. Players in a Showdown game do not know the full state of the game (e.g. a player doesn\u0026rsquo;t know data about their opponent\u0026rsquo;s Pokemon). The search space of each game is effectively infinite with hidden branches (each move has an element of randomness associated with it, and we do not know which moves the opponent has), so a tree search based algorithm such as MCTS in AlphaGo doesn\u0026rsquo;t quite make sense. I liked the idea of a balance between chess (two-player, zero-sum) and poker (imperfect information). Regarding project feasibility, I felt that (without proof) Showdown RL algorithms have a much lower computational necessity than say the $35 billion price tag of AlphaGo. I am still not sure about the last point, but I can say for a fact that using Google Colab\u0026rsquo;s free resources is definitely not enough!\nTeam PokeRL had around 10 members, ranging from freshmen who had just learned to code to a PhD student with published research and graduate machine learning courses under his belt. As I hoped for each student to have a meaningful project experience while learning new material, setting expectations and developing educational material/lectures was challenging for me.\nI surveyed each member and partitioned teams based on interest, experience, and algorithms that they wished to explore. I challenged teams to create the best AI possible to be evaluated against other teams on gameday. Three teams were formed, self-named Elite4, Virn, and Solo Pokemon. I considered making my own team, but I mistakenly underestimated the time overhead of running the project, helping teams debug, discussing algorithmic details/implementation, and teaching general software/machine learning skills.\nWe met weekly on Sunday from 11am-2pm for seven weeks during the semester. Initially, I thought to split up each session with a 1 hour combined lecture and a 2 hour team work period. However, by the third session, I decided to shorten or cut out the lecture. Personalized focus time between each group provided a more valuable use of time. Groups varied in technical experience, and focus time allowed me to tailor my help individually. For advanced members, discussions replaced help.\nSet Up To kickstart each team, I provided each team with starter code with instructions to run and a greedy agent implementation, a simple DQN agent implementation (from the official documentation), and a tf/keras modeled player interface.\nInitially, I anticipated members to run their code locally. Instead, some were met with technical difficulties. As some of those people were less experienced, we lost valuable project session time helping them debug. I felt bad - the inability to set up is frustrating, and the student would feel less motivated, especially during a long three hour work session. This mistake on my part cost us limited productivity hours before I decided to shift everything to Google Colab. The migration was not so simple because I had to figure out how to run a local server within Colab (games are played through a socket connection to a local Showdown server). These issues would have never happened if I had been more proactive in my project preparation.\nAlgorithms As a baseline model, I created a greedy agent who is (almost) guaranteed to make a move that deals the most damage to the opponent\u0026rsquo;s current Pokemon. The greedy agent hovers slightly above 1000 ELO, the default player ELO, when deployed to the official Showdown server.\nSolo Pokemon and Virn developed unique heuristic, rule-based algorithms. Elite4 decided to try a neural network powered reinforcement learning algorithm.\nSolo Pokemon Solo Pokemon\u0026rsquo;s algorithm attempted to determine whether to play a greedy move, switch to another Pokemon (at the beginning of each game, players start with six Pokemon), or dynamax (a feature unique to the specific game mode in Showdown). If the current Pokemon had an unfavorable speed, a type disadvantage, and a high probability of fainting (when the Pokemon is unusable for the rest of the game) based on its current health and defense stats, Solo Pokemon opted to switch to another Pokemon. Dynamax was determined based on the alive Pokemon in their party, a strong type advantage, and the base stats of the current Pokemon. In all other cases, Solo Pokemon chose a greedy move.\nVirn Virn had a simple but effective approach. If the current Pokemon had the best move against the opponent Pokemon, then the current Pokemon would use that move, dynamaxing if the move was super effective (favorable type advantage). Otherwise, switch to the Pokemon on the bench with the best move.\nI think it is interesting to note that Solo Pokemon and Virn calculated the best move differently, although I won\u0026rsquo;t go into specific details as they require a bit more knowledge about the game.\nElite4 Elite4 used Deep Q-Learning with Experience Replay with Double DQN. More information about exact details can be found here: DQN paper, Double DQN paper, library implementation. This algorithm is fairly well documented and implemented, allowing the team to spend their time to experiment state vectorization, network architecture, reward calculation, opponent selection, and more. I doubt DQN is near an optimal approach to this problem, but I think DQN is a very solid choice of algorithm for a weekly, semester long team project #with less experienced students. I found it easier to build an intuition for this algorithm for those interested. Elite4 experimented with different ways to represent state based on the data given from the environment, settling on a state vector with 21 components combining Pokemon types, move powers and multipliers, statuses, and dynamax ability. They experimented with ways to represent reward and model architectures, settling on one with 7000 parameters. The model\u0026rsquo;s input is a state array, and its output is an array of action probabilities for 22 possible actions. I do not recall the exact values they used for parameters such as $\\epsilon$ for the $\\epsilon$-greedy policy, experience replay memory size, $\\gamma$ for reward discount factor, among other tunable parameters.\nTo train, Elite4 first trained their model through battles against the greedy agent until they had a ~60% win rate. Then, Elite4 trained against an opponent with a fixed snapshot of its model, periodically updating the opponent\u0026rsquo;s model if the current model consistently beat the opponent. The team attempted to train on Colab, but their methods were still too time consuming and computationally intensive for reaching satisfactory results. Nevertheless, they attained a model trained for about 15 hours.\nResults Against the greedy agent, Solo Pokemon and Virn claimed a 75% win rate, while Elite4 had a 65% win rate.\nThe table below shows the results of a round robin tournament between the three teams.\nGames won out of 1000; row represents challenger and column represents opponent\n    Solo Pokemon Virn Elite4     Solo Pokemon - 451 596   Virn 549 - 656   Elite4 404 344 -    Interestingly, battles were quite fair - no team was completely wiped/wiped other teams. I was suprised by Elite4\u0026rsquo;s relatively formidable results, despite the difficulties in training and challenges that the team faced throughout the semester. With current approaches, Virn is the winner of MDST PokeRL with 55% win rate over Solo Pokemon and a 65% win rate over Elite4!\nBelow you can watch one battle between each team.\n   From a human perspective, we can see the mistakes that agents are making. These mistakes are generally easier to fix for heuristic based agents but not so simple for an RL trained agent. Further Work I mentioned above that I was also interested in creating my own RL agent with a more sophisticated model and algorithm selection and training based on my knowledge. Although I did not have time in the semester due to my position, I decided to tackle this problem afterward. Due to my internship, I didn\u0026rsquo;t have much time to work, but I am gaining progress in my approach. My current results are not in a presentable state, but I will update this post in the future with results. I aim to get as good of an AI as possible with a solid ELO rating and acceptable performance against most active users on Showdown.\n2022 Update: I ported state and network model representations to pytorch. I then used a library called mushroom_rl and implemented a training loop with it. I spun up an AWS GPU instance to put all my hard work together. Exciting stuff! A few hours into the training run, I check in anddddddddddddddddddddddddddd the code is hanging. Hmm, what\u0026rsquo;s wrong?!? I diagnose the problem as an issue in battle simulation and after further investigation, I find a concurrency bug. I thought about this bug on and off for a long, long time but have no working solution. My priorities have changed and perhaps with full-time headbashing effort, I can engineer a solution. But for now, this quest is on pause.\nEither way, I don\u0026rsquo;t think reinforcement learning purely is the best way to approach this problem. Ideally, I\u0026rsquo;d collect a large game database (perhaps a good use of my scraping knowledge), pretrain an attention-based network, and add in search and/or self play based techniques at the very end.\n","date":1629773175,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1629773175,"objectID":"e85a169fcd445686e8ee2bcd0a562a48","permalink":"https://www.neelsh.com/post/reflections-pokerl/","publishdate":"2021-08-23T22:46:15-04:00","relpermalink":"/post/reflections-pokerl/","section":"post","summary":"Pokemon Reinforcement Learning: thoughts from a project leader perspective","tags":[],"title":"Creating Pokemon AI","type":"post"},{"authors":["Neel Shah"],"categories":[],"content":"As my junior year of high school drew to a close in May 2018, a sense of emptiness loomed over the upcoming summer. My Science Fair project experience and an interest in materials science and mechanical engineering compelled me to seek research opportunities at nearby universities. I began scrolling faculty pages and cold emailing galore.\nTo my dismay, nearly all professors I contacted ghosted me, but one graciously agreed to meet me. Our conversation unveiled two research avenues: chemical combustion graph analysis and machine learning based predictive models for combustion properties. He shared ten papers with me, and I spent the next few weeks heads-deep in reading.\nOne paper, Planning chemical syntheses with deep neural networks and symbolic AI by Segler et al., particularly caught my eye in the sea of literature. I spent nearly a week trying to understand the paper with no success whatsoever. But the mountains of information I came across while learning piqued my curiosity in machine learning because the technical details aligned with my academic skills and interests. Fun fact: the creator of one site that I printed out Rubik\u0026rsquo;s cube techniques for back in 2011 happened to teach a popular deep learning course, CS231n - the original implement of a deep learning course I took at UMich, and now works on cool autopilot stuff at Tesla and intelligence at OpenAI.\nWe decided to demonstrate accurate predictive models for autoignition and flame properties using machine learning methods. Specifically, I used random forests and neural networks on various datasets to predict ignition delay times, laminar flame speeds, octane ratings, and CA50 values in HCCI engines. We believed machine learning models can alleviate long-held limitations from traditional empirical models. For example, the chemical kinetics and resultant intermediaries of most reactions can change drastically based on pressure and temperature.\nI filled my summer reading and understanding relevant papers, writing code, running experiments, and presenting to the research group. Don\u0026rsquo;t worry, I still had fun hanging out with friends and family as a high schooler should!\nDuring the school year, I refined a write-up that was accepted to SAE World Congress Experience 2019 (SAE WCX 2019). From April 9-11th, 2019, I missed my school mornings to attend the conference, network with, and see talks and demos from industry leaders. The experience was surreal. On the day of my talk, I came up sick and was losing my voice. My stomach sank before the presentation began, and my heartbeats permeated across my body. I had lost half of my voice in front of a crowd of around 70 people. I had doubts about my knowledge: what can a high schooler teach to industry veterans or people with graduate degrees in this field?\nThe talk itself was a blur. Once I began, I boldly shared my presentation that I had spent so long preparing with work that I had known for 11 months (with 3 months of focused work). Afterward, I fielded questions. I don\u0026rsquo;t remember that part now, but I do recall some questions being quite difficult to answer. I know for sure that I did answer them to the best of my ability. I think the talk was 20 minutes long with 10 minutes of questions, but it may have been longer; I honestly can\u0026rsquo;t remember now over two years later.\nThis project was a great first University level research experience for me. I learned that I was capable of picking up new information and generating valuable work even without a traditional background (e.g. degree or course experience). I picked up the skill of reading and understanding academic papers. I experienced an academic conference as a presenter. I overcame many technical problems during my work - even identifying a mistake in the paper for one state-of-the-art empirical model.\nThis webpage has a picture of me after my talk and this ResearchGate link goes to my conference published paper which currently seems to have 7 citations!\nI had a short research stint in university. After significant consideration, I decided to put aside my research aspirations for other professional interests. The incentive structure and pace of a business align better with my disposition. I still skim a research paper here and there ðŸ˜Š.\n","date":1621022728,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621022728,"objectID":"665f4fa14aabae3fd741ff58db94235d","permalink":"https://www.neelsh.com/post/first-university-research/","publishdate":"2021-05-14T16:05:28-04:00","relpermalink":"/post/first-university-research/","section":"post","summary":"The story behind my first published work","tags":[],"title":"How I published research in high school","type":"post"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)   Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/media/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}   Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }   Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://www.neelsh.com/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"https://www.neelsh.com/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"ce6f3bce504c23757ffb63738465b3b0","permalink":"https://www.neelsh.com/project/comingsoon/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/project/comingsoon/","section":"project","summary":"","tags":null,"title":"Coming Soon","type":"project"}]